<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Simulador de Lego 48x48</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --board-size: 48;
      --cell-size: 18px;
    }
    .grid-board {
      display: grid;
      grid-template-columns: repeat(var(--board-size), var(--cell-size));
      grid-template-rows: repeat(var(--board-size), var(--cell-size));
      gap: 0;
      transform-origin: top left;
    }
    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background: #f1f1f1;
      border: 1px solid #ddd;
      box-sizing: border-box;
    }
    .piece-preview {
      width: 48px;
      height: 48px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      box-sizing: border-box;
      border-radius: 8px;
      border: 2px solid #000;
      box-shadow: inset 2px 2px 4px rgba(255,255,255,.6), inset -2px -2px 4px rgba(0,0,0,.4), 2px 2px 6px rgba(0,0,0,.4);
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-6">

  <h1 class="text-2xl font-bold mb-2 text-center">Louveira SDC Training</h1>
  <p class="text-sm text-gray-600 mb-1 text-center">O DC mede 24m x 24m. (a distância de cada 'quadradinho é de 1/2m)</p>
  <p class="text-sm text-gray-600 mb-4 text-center">Clique esquerdo: colocar peça • Clique direito: apagar peça inteira</p>

  <div class="flex gap-8 w-full justify-center">
    <!-- Painel de Peças -->
    <div class="bg-white p-4 rounded-2xl shadow w-64">
      <h2 class="font-semibold mb-3">Peças 2x2</h2>
      <div id="palette" class="space-y-3"></div>
    </div>

    <!-- Tabuleiro -->
    <div class="bg-white p-4 rounded-2xl shadow overflow-auto max-w-[75vw] max-h-[80vh]">
      <div id="boardWrapper" class="relative w-full">
        <div id="board" class="grid-board" role="grid" aria-label="Tabuleiro 48 por 48"></div>
      </div>
    </div>
  </div>

  <script>
    const BOARD_SIZE = 48;
    const boardWrapper = document.getElementById('boardWrapper');
    const board = document.getElementById('board');
    const palette = document.getElementById('palette');

    // Peças atualizadas
    const piecesData = [
      { name: 'Amarelo', color: 'yellow', count: 20 },
      { name: 'Preto', color: 'black', count: 40 },
      { name: 'Azul', color: 'blue', count: 40 },
      { name: 'Vermelho', color: 'red', count: 40 },
      { name: 'Verde', color: 'green', count: 40 },
      { name: 'Marrom', color: 'brown', count: 10 },
      { name: 'Laranja', color: 'orange', count: 10 },
      { name: 'Branca', color: 'white', count: 10 },
    ];

    const grid = [];
    const boardState = Array(BOARD_SIZE * BOARD_SIZE).fill(null);
    const pieceTypeById = {};
    let pieceIdCounter = 1;

    // Cria as células do tabuleiro
    for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      board.appendChild(cell);
      grid.push(cell);
    }

    let selectedPiece = null;

    function renderPalette() {
      palette.innerHTML = '';

      piecesData.forEach((piece, index) => {
        const container = document.createElement('div');
        container.className = 'flex items-center gap-3 cursor-pointer select-none';

        const preview = document.createElement('div');
        preview.className = 'piece-preview rounded';
        preview.style.background = piece.color;

        if (piece.color === 'white') {
          preview.style.border = '2px solid #000';
        }

        const info = document.createElement('div');
        info.innerHTML = `<div class="font-medium">${piece.name}</div><div class="text-sm">Restantes: ${piece.count}</div>`;

        container.onclick = () => selectedPiece = index;

        container.appendChild(preview);
        container.appendChild(info);
        palette.appendChild(container);
      });
    }

    renderPalette();

    function resetCell(i) {
      grid[i].style.background = '';
      grid[i].style.boxShadow = '';
      grid[i].style.border = '1px solid #ddd';
      grid[i].style.borderTop = '';
      grid[i].style.borderRight = '';
      grid[i].style.borderBottom = '';
      grid[i].style.borderLeft = '';
      boardState[i] = null;
    }

    function erasePieceById(pid) {
      if (!pid) return;
      const pieceType = pieceTypeById[pid];

      boardState.forEach((val, i) => {
        if (val === pid) resetCell(i);
      });

      if (pieceType !== undefined) {
        piecesData[pieceType].count++;
        delete pieceTypeById[pid];
        renderPalette();
      }
    }

    function applyOuterBorder(baseIndex) {
      const topLeft = baseIndex;
      const topRight = baseIndex + 1;
      const bottomLeft = baseIndex + BOARD_SIZE;
      const bottomRight = baseIndex + BOARD_SIZE + 1;

      [topLeft, topRight, bottomLeft, bottomRight].forEach(i => {
        grid[i].style.border = '1px solid #ddd';
        grid[i].style.borderTop = '';
        grid[i].style.borderRight = '';
        grid[i].style.borderBottom = '';
        grid[i].style.borderLeft = '';
      });

      grid[topLeft].style.borderTop = '2px solid black';
      grid[topRight].style.borderTop = '2px solid black';
      grid[bottomLeft].style.borderBottom = '2px solid black';
      grid[bottomRight].style.borderBottom = '2px solid black';
      grid[topLeft].style.borderLeft = '2px solid black';
      grid[bottomLeft].style.borderLeft = '2px solid black';
      grid[topRight].style.borderRight = '2px solid black';
      grid[bottomRight].style.borderRight = '2px solid black';
    }

    grid.forEach((cell, index) => {
      cell.addEventListener('click', () => {
        const row = Math.floor(index / BOARD_SIZE);
        const col = index % BOARD_SIZE;

        if (col === BOARD_SIZE - 1 || row === BOARD_SIZE - 1) return;

        const indices = [
          index,
          index + 1,
          index + BOARD_SIZE,
          index + BOARD_SIZE + 1
        ];

        if (selectedPiece === null) return;
        const piece = piecesData[selectedPiece];
        if (piece.count <= 0) return;
        if (indices.some(i => boardState[i] !== null)) return;

        const newId = pieceIdCounter++;
        pieceTypeById[newId] = selectedPiece;

        indices.forEach(i => {
          grid[i].style.background = piece.color + " linear-gradient(145deg, rgba(255,255,255,.3), rgba(0,0,0,.3))";
          grid[i].style.backgroundBlendMode = 'overlay';
          grid[i].style.boxShadow = 'inset 2px 2px 4px rgba(255,255,255,.6), inset -2px -2px 4px rgba(0,0,0,.4), 2px 2px 4px rgba(0,0,0,.4)';
          grid[i].style.border = '1px solid #ddd';
          boardState[i] = newId;
        });

        applyOuterBorder(index);
        piece.count--;
        renderPalette();
      });

      cell.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const pid = boardState[index];
        if (!pid) return;
        erasePieceById(pid);
      });
    });

    // Ajustar escala automaticamente para caber na tela (sem rolagem lateral)
    function fitBoardToScreen() {
      const boardWidth = BOARD_SIZE * 18; // 48 * 18px
      const availableWidth = boardWrapper.clientWidth;
      const scale = Math.min(1, availableWidth / boardWidth);
      board.style.transform = `scale(${scale})`;
    }

    window.addEventListener('resize', fitBoardToScreen);
    fitBoardToScreen();

    // Sanity checks
    console.assert(grid.length === BOARD_SIZE * BOARD_SIZE, 'Erro: quantidade de células incorreta');
    console.assert(boardState.length === BOARD_SIZE * BOARD_SIZE, 'Erro: boardState com tamanho errado');
  </script>
</body>
</html>
